<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[汉字转拼音]]></title>
    <url>%2F2018%2F11%2F08%2Fhanzizhuanpinyin%2F</url>
    <content type="text"><![CDATA[汉语拼音转换（hàn yǔ pīn yīn zhuǎn huàn）有的项目需要转换中文字符为拼音，甚至还要带上音节。其实很简单，GitHub上已经有大神写出来了，我们直接用就行了，本文主要讲讲如何使用该转换工具——pinyin 插件介绍 名称： pinyin 特性： 根据词组智能匹配最正确的拼音支持多音字简单的繁体支持支持多种不同拼音风格 安装： npm install pinyin 开始使用简单使用code： let pinyin = require("pinyin"); console.log(pinyin("汉语拼音转换，真高兴")); result： Array (9 items) 0: ["han"] 1: ["zi"] 2: ["zhuan"] 3: ["pin"] 4: ["yin"] 5: ["，"] 6: ["zhen"] 7: ["gao"] 8: ["xing"] Array Prototype 可以看出来，使用方式很简单：pinyin(words[, options])，转换的结果是以数组的形式输出的。 加上音节code： let pinyin = require("pinyin") console.log(pinyin("汉字转拼音，真高兴",{ style:pinyin.STYLE_TONE })); result： Array (9 items) 0: ["hàn"] 1: ["zì"] 2: ["zhuǎn"] 3: ["pīn"] 4: ["yīn"] 5: ["，"] 6: ["zhēn"] 7: ["gāo"] 8: ["xīng"] Array Prototype 已经为文字加上音节了，这里需要多说一句，加音节的语法是：&lt;Object&gt; options.style，可以通过以下几种 STYLE_ 开头的静态属性进行指定： 静态属性 .STYLE_NORMAL 普通风格，即不带音标。如：pin yin .STYLE_TONE 声调风格，拼音声调在韵母第一个字母上。注：这是默认的风格。如：pīn yīn .STYLE_TONE2 声调风格 2，即拼音声调以数字形式在各个拼音之后，用数字 [0-4] 进行表示。如：pin1 yin1 .STYLE_TO3NE 声调风格 3，即拼音声调以数字形式在注音字符之后，用数字 [0-4] 进行表示。如：pi1n yi1n .STYLE_INITIALS 声母风格，只返回各个拼音的声母部分。对于没有声母的汉字，返回空白字符串。如：中国 的拼音 zh g注：声明风格会区分 zh 和 z，ch 和 c，sh 和 s。注意：部分汉字没有声母，如 啊，饿 等，另外 y, w, yu 都不是声母， 这些汉字的拼音声母风格会返回 “”。请仔细考虑你的需求是否应该使用首字母风格。 详情请参考 为什么没有 y, w, yu 几个声母 .STYLE_FIRST_LETTER 首字母风格，只返回拼音的首字母部分。如：p y 多音字模式和分词模式仔细观察刚刚的结果会发现：最后两个字“高兴”的拼音是错的。 &lt;Boolean&gt; options.segment 是否启用分词模式，中文分词有助于极大的降低多音字问题。 但性能会极大的下降，内存也会使用更多。 &lt;Boolean&gt; options.heteronym 是否启用多音字模式，默认关闭。关闭多音字模式时，返回每个汉字第一个匹配的拼音。启用多音字模式时，返回多音字的所有拼音列表。 code： let pinyin = require("pinyin") console.log(pinyin("汉字转拼音，真高兴", { style:pinyin.STYLE_TONE, heteronym: true, // 启用多音字模式 segment: true // 启用分词，以解决多音字问题。 })); result： Array (9 items) 0: ["hàn"] 1: ["zì"] 2: ["zhuǎn"] 3: ["pīn"] 4: ["yīn"] 5: ["，"] 6: ["zhēn"] 7: ["gāo"] 8: ["xìng"] Array Prototype 现在就行了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（一）：let和const]]></title>
    <url>%2F2018%2F10%2F31%2Fletandconst%2F</url>
    <content type="text"><![CDATA[ES6（一）：let和const一、let1. let基本用法&emsp;&emsp;相当于var,但是又与var不同，因为let声明的变量只能在let所在的代码块中有效。&emsp;&emsp;从以下两段代码以及对应的输出结果可以很明显的看出var与let的区别。code： 1234for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); result： 123456012345 code： 1234for (let i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); result： 12345601234ReferenceError: i is not defined 2. 块级作用域&emsp;&emsp;众所周知，在ES5中只有全局作用域和函数作用域，没有我们所谓的块级作用域。&emsp;&emsp;这不禁让我想起一个面试题：code： 1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); &emsp;&emsp;问：上面这段代码输出的结果是什么？&emsp;&emsp;仔细琢磨一下我们很容易得出正确的答案： result： 1234562018-10-31T06:55:30.020Z 52018-10-31T06:55:31.021Z 52018-10-31T06:55:31.021Z 52018-10-31T06:55:31.022Z 52018-10-31T06:55:31.022Z 52018-10-31T06:55:31.022Z 5 &emsp;&emsp;仔细看一下发现：由于setTimeout会被JavaScript延迟执行，因此是先输出最底部的console.log，隔一秒之后再执行循环里面的consol.log,此时i已经全部是5。&emsp;&emsp;那我们怎么样才能使输出结果变成想要的0,1,2,3,4呢？&emsp;&emsp;明白了let的原理之后其实问题变得很简单：code： 1234567for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); &emsp;&emsp;这样就行了吗？result： 1ReferenceError: i is not defined &emsp;&emsp;哈哈，刚刚还说过let只在所在的代码块里面有效，这里最外层的console.log很明显找不到i，所以报出引用错误。想要得到正确答案其实还需要去掉最后一行console.log。&emsp;&emsp;当然这个题目要搁以前的话，首先想到的解决方案应该是IIFE（Immediately Invoked Function Expression：声明即执行的函数表达式）来解决闭包造成的问题。code： 123456789for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(new Date, j); &#125;, 1000); &#125;)(i);&#125;console.log(new Date, i); result： 1234562018-10-31T07:17:45.825Z 52018-10-31T07:17:46.827Z 02018-10-31T07:17:46.827Z 12018-10-31T07:17:46.827Z 22018-10-31T07:17:46.827Z 32018-10-31T07:17:46.827Z 4 &emsp;&emsp;由此我们是不是就可以得出一个结论，有了let，我们就可以抛弃IIFE了？&emsp;&emsp;这个暂时还不好说，我们还是继续看看let的其他特性。 3. 没有变量提升&emsp;&emsp;var命令会产生变量提升的现象，这使得js这门语言变得并不严谨，这一点是特点也是鸡肋。用var声明的变量，如果我们在声明之前使用，则它的值为undefined。&emsp;&emsp;而当我们用let定义变量时，就必须严格按照先定义再使用的原则了，反之则会抛出一个大大的引用错误（ReferenceError），显然这更符合人们的使用习惯。code： 12345console.log(a);var a = 2;console.log(b);let b = 2; result： 12undefinedReferenceError: b is not defined 4. 暂时性死区及不能重复声明&emsp;&emsp;ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。&emsp;&emsp;总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。&emsp;&emsp;“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。&emsp;&emsp;let不允许在相同作用域内，重复声明同一个变量。 二、const1. const基本用法&emsp;&emsp;const命令是声明一个常量，用法和let一样。 和let的相同之处是： const与let作用域相同，都是只在声明的代码块中起作用 const也不会提升所声明的常量 const也不能重复声明 不同之处是const声明的常量在声明时就必须赋值，因为一旦声明就不能改变改常量的值 2. 真的不能改变吗？&emsp;&emsp;const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。code&amp;result： 12345678const a=1;a=2;//TypeErrorconst obj=&#123; b:3, c:4&#125;obj.b=5;console.log(obj);//&#123;b:5,c:4&#125; 参考资料 《ECMAScript 6 入门》——阮一峰 破解前端面试（80% 应聘者不及格系列）：从闭包说起——王仕军知乎专栏：前端周刊 ECMAScript2015官方标准]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
